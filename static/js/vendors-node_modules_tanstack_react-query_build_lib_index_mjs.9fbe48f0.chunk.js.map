{"version":3,"file":"static/js/vendors-node_modules_tanstack_react-query_build_lib_index_mjs.9fbe48f0.chunk.js","mappings":"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","sources":["../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../node_modules/use-sync-external-store/shim/index.js","../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@tanstack/query-core/src/subscribable.ts","../node_modules/@tanstack/query-core/src/utils.ts","../node_modules/@tanstack/query-core/src/focusManager.ts","../node_modules/@tanstack/query-core/src/onlineManager.ts","../node_modules/@tanstack/query-core/src/retryer.ts","../node_modules/@babel/runtime/helpers/esm/get.js","../node_modules/@babel/runtime/helpers/esm/superPropBase.js","../node_modules/@tanstack/query-core/src/logger.ts","../node_modules/@tanstack/query-core/src/notifyManager.ts","../node_modules/@tanstack/query-core/src/removable.ts","../node_modules/@tanstack/query-core/src/query.ts","../node_modules/@tanstack/query-core/src/queryCache.ts","../node_modules/@tanstack/query-core/src/mutation.ts","../node_modules/@tanstack/query-core/src/mutationCache.ts","../node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts","../node_modules/@tanstack/query-core/src/queryClient.ts","../node_modules/@tanstack/query-core/src/queryObserver.ts","../node_modules/@tanstack/query-core/src/queriesObserver.ts","../node_modules/@tanstack/query-core/src/infiniteQueryObserver.ts","../node_modules/@tanstack/query-core/src/mutationObserver.ts","../node_modules/@tanstack/query-core/src/hydration.ts","../node_modules/@tanstack/react-query/src/useSyncExternalStore.ts","../node_modules/@tanstack/react-query/src/QueryClientProvider.tsx","../node_modules/@tanstack/react-query/src/isRestoring.tsx","../node_modules/@tanstack/react-query/src/QueryErrorResetBoundary.tsx","../node_modules/@tanstack/react-query/src/utils.ts","../node_modules/@tanstack/react-query/src/errorBoundaryUtils.ts","../node_modules/@tanstack/react-query/src/suspense.ts","../node_modules/@tanstack/react-query/src/useQueries.ts","../node_modules/@tanstack/react-query/src/useBaseQuery.ts","../node_modules/@tanstack/react-query/src/useQuery.ts","../node_modules/@tanstack/react-query/src/Hydrate.tsx","../node_modules/@tanstack/react-query/src/useIsFetching.ts","../node_modules/@tanstack/react-query/src/useIsMutating.ts","../node_modules/@tanstack/react-query/src/useMutation.ts","../node_modules/@tanstack/react-query/src/useInfiniteQuery.ts"],"sourcesContent":["/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}","import _typeof from \"./typeof.js\";\nexport default function _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  };\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    defineProperty = Object.defineProperty || function (obj, key, desc) {\n      obj[key] = desc.value;\n    },\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return defineProperty(generator, \"_invoke\", {\n      value: makeInvokeMethod(innerFn, self, context)\n    }), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    defineProperty(this, \"_invoke\", {\n      value: function value(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = \"suspendedStart\";\n    return function (method, arg) {\n      if (\"executing\" === state) throw new Error(\"Generator is already running\");\n      if (\"completed\" === state) {\n        if (\"throw\" === method) throw arg;\n        return doneResult();\n      }\n      for (context.method = method, context.arg = arg;;) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n        if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n          if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n          context.dispatchException(context.arg);\n        } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n        state = \"executing\";\n        var record = tryCatch(innerFn, self, context);\n        if (\"normal\" === record.type) {\n          if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        }\n        \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method,\n      method = delegate.iterator[methodName];\n    if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel;\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (val) {\n    var object = Object(val),\n      keys = [];\n    for (var key in object) keys.push(key);\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: Set<{ listener: TListener }>\n\n  constructor() {\n    this.listeners = new Set()\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    const identity = { listener }\n    this.listeners.add(identity)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(identity)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n  return\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  private focused?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', listener, false)\n        window.addEventListener('focus', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n          window.removeEventListener('focus', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    this.focused = focused\n\n    if (focused) {\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState,\n    )\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void,\n) => (() => void) | undefined\n\nconst onlineEvents = ['online', 'offline'] as const\n\nexport class OnlineManager extends Subscribable {\n  private online?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        onlineEvents.forEach((event) => {\n          window.addEventListener(event, listener, false)\n        })\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach((event) => {\n            window.removeEventListener(event, listener)\n          })\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    this.online = online\n\n    if (online) {\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}","export interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\nexport const defaultLogger: Logger = console\n","import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends unknown[]> = (...args: T) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends unknown[]>(\n    callback: BatchCallsCallback<T>,\n  ): BatchCallsCallback<T> => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n","import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  cacheTime!: number\n  private gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  protected updateCacheTime(newCacheTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      newCacheTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout)\n      this.gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n","import { getAbortController, noop, replaceData, timeUntilStale } from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n  QueryMeta,\n  CancelOptions,\n  SetDataOptions,\n  FetchStatus,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport type { Retryer } from './retryer'\nimport { isCancelledError, canFetch, createRetryer } from './retryer'\nimport { Removable } from './removable'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  logger?: Logger\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: any\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal?: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n  ) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  initialState: QueryState<TData, TError>\n  revertState?: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  private cache: QueryCache\n  private logger: Logger\n  private promise?: Promise<TData>\n  private retryer?: Retryer<TData>\n  private observers: QueryObserver<any, any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  private abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.abortSignalConsumed = false\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.logger = config.logger || defaultLogger\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || getDefaultState(this.options)\n    this.state = this.initialState\n    this.scheduleGc()\n  }\n\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some((observer) => observer.options.enabled !== false)\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({ revert: true })\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = getAbortController()\n\n    // Create query function context\n    const queryFnContext: QueryFunctionContext<TQueryKey> = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true\n            return abortController.signal\n          }\n          return undefined\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\n          `Missing queryFn for queryKey '${this.options.queryHash}'`,\n        )\n      }\n      this.abortSignalConsumed = false\n      return this.options.queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData, TQueryKey> = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(context)\n\n    // Store state in case the current fetch needs to be reverted\n    this.revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.cache.config.onError?.(error, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.retryer = createRetryer({\n      fn: context.fetchFn as () => TData,\n      abort: abortController?.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        this.setData(data as TData)\n\n        // Notify cache callback\n        this.cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.promise = this.retryer.promise\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = typeof data !== 'undefined'\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle',\n  }\n}\n","import type { QueryFilters } from './utils'\nimport { hashQueryKeyByOptions, matchQuery, parseFilterArgs } from './utils'\nimport type { Action, QueryState } from './query'\nimport { Query } from './query'\nimport type { NotifyEvent, QueryKey, QueryOptions } from './types'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  config: QueryCacheConfig\n\n  private queries: Query<any, any, any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor(config?: QueryCacheConfig) {\n    super()\n    this.config = config || {}\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter((x) => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKey,\n    arg2?: QueryFilters,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.queries.find((query) => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKey, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return Object.keys(filters).length > 0\n      ? this.queries.filter((query) => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","import type { MutationOptions, MutationStatus, MutationMeta } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport type { Retryer } from './retryer'\nimport { canFetch, createRetryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  logger?: Logger\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n  meta?: MutationMeta\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  private mutationCache: MutationCache\n  private logger: Logger\n  private retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.defaultOptions = config.defaultOptions\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.logger = config.logger || defaultLogger\n    this.observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options?: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc()\n      } else {\n        this.mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return this.retryer?.continue() ?? this.execute()\n  }\n\n  async execute(): Promise<TData> {\n    const executeMutation = () => {\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found')\n          }\n          return this.options.mutationFn(this.state.variables!)\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({ type: 'failed', failureCount, error })\n        },\n        onPause: () => {\n          this.dispatch({ type: 'pause' })\n        },\n        onContinue: () => {\n          this.dispatch({ type: 'continue' })\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode,\n      })\n\n      return this.retryer.promise\n    }\n\n    const restored = this.state.status === 'loading'\n    try {\n      if (!restored) {\n        this.dispatch({ type: 'loading', variables: this.options.variables! })\n        // Notify cache callback\n        await this.mutationCache.config.onMutate?.(\n          this.state.variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(this.state.variables!)\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables,\n          })\n        }\n      }\n      const data = await executeMutation()\n\n      // Notify cache callback\n      await this.mutationCache.config.onSuccess?.(\n        data,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(\n        data,\n        this.state.variables!,\n        this.state.context!,\n      )\n\n      // Notify cache callback\n      await this.mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(\n        data,\n        null,\n        this.state.variables!,\n        this.state.context,\n      )\n\n      this.dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.mutationCache.config.onError?.(\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n\n        await this.options.onError?.(\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.mutationCache.config.onSettled?.(\n          undefined,\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.dispatch({ type: 'error', error: error as TError })\n      }\n    }\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'loading':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n","import type { MutationObserver } from './mutationObserver'\nimport type { MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport { notifyManager } from './notifyManager'\nimport type { Action, MutationState } from './mutation'\nimport { Mutation } from './mutation'\nimport type { MutationFilters } from './utils'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\ntype MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  config: MutationCacheConfig\n\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n  private resuming: Promise<unknown> | undefined\n\n  constructor(config?: MutationCacheConfig) {\n    super()\n    this.config = config || {}\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter((x) => x !== mutation)\n    this.notify({ type: 'removed', mutation })\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.mutations.forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.mutations.find((mutation) => matchMutation(filters, mutation))\n  }\n\n  findAll(filters: MutationFilters): Mutation[] {\n    return this.mutations.filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    this.resuming = (this.resuming ?? Promise.resolve())\n      .then(() => {\n        const pausedMutations = this.mutations.filter((x) => x.state.isPaused)\n        return notifyManager.batch(() =>\n          pausedMutations.reduce(\n            (promise, mutation) =>\n              promise.then(() => mutation.continue().catch(noop)),\n            Promise.resolve() as Promise<unknown>,\n          ),\n        )\n      })\n      .then(() => {\n        this.resuming = undefined\n      })\n\n    return this.resuming\n  }\n}\n","import type { QueryBehavior } from './query'\n\nimport type {\n  InfiniteData,\n  QueryFunctionContext,\n  QueryOptions,\n  RefetchQueryFilters,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData,\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = () => {\n        const refetchPage: RefetchQueryFilters['refetchPage'] | undefined =\n          context.fetchOptions?.meta?.refetchPage\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal?.aborted) {\n                cancelled = true\n              } else {\n                context.signal?.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn ||\n          (() =>\n            Promise.reject(\n              `Missing queryFn for queryKey '${context.options.queryHash}'`,\n            ))\n\n        const buildNewPages = (\n          pages: unknown[],\n          param: unknown,\n          page: unknown,\n          previous?: boolean,\n        ) => {\n          newPageParams = previous\n            ? [param, ...newPageParams]\n            : [...newPageParams, param]\n          return previous ? [page, ...pages] : [...pages, page]\n        }\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean,\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then((page) =>\n            buildNewPages(pages, param, page, previous),\n          )\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          const shouldFetchFirstPage =\n            refetchPage && oldPages[0]\n              ? refetchPage(oldPages[0], 0, oldPages)\n              : true\n\n          // Fetch first page\n          promise = shouldFetchFirstPage\n            ? fetchPage([], manual, oldPageParams[0])\n            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then((pages) => {\n              const shouldFetchNextPage =\n                refetchPage && oldPages[i]\n                  ? refetchPage(oldPages[i], i, oldPages)\n                  : true\n\n              if (shouldFetchNextPage) {\n                const param = manual\n                  ? oldPageParams[i]\n                  : getNextPageParam(context.options, pages)\n                return fetchPage(pages, manual, param)\n              }\n              return Promise.resolve(\n                buildNewPages(pages, oldPageParams[i], oldPages[i]),\n              )\n            })\n          }\n        }\n\n        const finalPromise = promise.then((pages) => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n  return\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n  return\n}\n","import type { QueryFilters, Updater, MutationFilters } from './utils'\nimport {\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n  hashQueryKeyByOptions,\n  functionalUpdate,\n} from './utils'\nimport type {\n  QueryClientConfig,\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n  WithRequired,\n} from './types'\nimport type { QueryState } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type { CancelOptions, DefaultedQueryObserverOptions } from './types'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private logger: Logger\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private mountCount: number\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.logger = config.logger || defaultLogger\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n    this.mountCount = 0\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\n        `Passing a custom logger has been deprecated and will be removed in the next major version.`,\n      )\n    }\n  }\n\n  mount(): void {\n    this.mountCount++\n    if (this.mountCount !== 1) return\n\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.mountCount--\n    if (this.mountCount !== 0) return\n\n    this.unsubscribeFocus?.()\n    this.unsubscribeFocus = undefined\n\n    this.unsubscribeOnline?.()\n    this.unsubscribeOnline = undefined\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetchStatus = 'fetching'\n    return this.queryCache.findAll(filters).length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.mutationCache.findAll({ ...filters, fetching: true }).length\n  }\n\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): TQueryFnData | undefined {\n    return this.queryCache.find<TQueryFnData>(queryKey, filters)?.state.data\n  }\n\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: WithRequired<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | WithRequired<\n          FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const cachedData = this.getQueryData<TData>(parsedOptions.queryKey!)\n\n    return cachedData\n      ? Promise.resolve(cachedData)\n      : this.fetchQuery(parsedOptions)\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return this.getQueryCache()\n      .findAll(queryKeyOrFilters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): TQueryFnData | undefined {\n    const query = this.queryCache.find<TQueryFnData>(queryKey)\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(queryKeyOrFilters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.queryCache.find<TQueryFnData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | ResetQueryFilters,\n    arg2?: ResetQueryFilters | ResetOptions,\n    arg3?: ResetOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions,\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(cancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | RefetchQueryFilters,\n    arg2?: RefetchQueryFilters | RefetchOptions,\n    arg3?: RefetchOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) =>\n          query.fetch(undefined, {\n            ...options,\n            cancelRefetch: options?.cancelRefetch ?? true,\n            meta: { refetchPage: filters.refetchPage },\n          }),\n        ),\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    return this.mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getLogger(): Logger {\n    return this.logger\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<unknown, any, any, any>,\n  ): void {\n    const result = this.queryDefaults.find(\n      (x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    if (!queryKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.queryDefaults.find((x) =>\n      partialMatchKey(queryKey, x.queryKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter((x) =>\n        partialMatchKey(queryKey, x.queryKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several query defaults match with key '${JSON.stringify(\n            queryKey,\n          )}'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>,\n  ): void {\n    const result = this.mutationDefaults.find(\n      (x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    if (!mutationKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.mutationDefaults.find((x) =>\n      partialMatchKey(mutationKey, x.mutationKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter((x) =>\n        partialMatchKey(mutationKey, x.mutationKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several mutation defaults match with key '${JSON.stringify(\n            mutationKey,\n          )}'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  defaultQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey extends QueryKey,\n  >(\n    options?:\n      | QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n","import type { DefaultedQueryObserverOptions, RefetchPageFilters } from './types'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\nimport type { Query, QueryState, Action, FetchOptions } from './query'\nimport type { QueryClient } from './queryClient'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch, isCancelledError } from './retryer'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  private currentQueryInitialState!: QueryState<TQueryData, TError>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private selectError: TError | null\n  private selectFn?: (data: TQueryData) => TData\n  private selectResult?: TData\n  private staleTimeoutId?: ReturnType<typeof setTimeout>\n  private refetchIntervalId?: ReturnType<typeof setInterval>\n  private currentRefetchInterval?: number | false\n  private trackedProps!: Set<keyof QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = new Set()\n    this.selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryOptions(options)\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      typeof options?.isDataEqual !== 'undefined'\n    ) {\n      this.client\n        .getLogger()\n        .error(\n          `The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option`,\n        )\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.currentRefetchInterval)\n    ) {\n      this.updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.client.getQueryCache().build(this.client, options)\n\n    return this.createResult(query, options)\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch<TPageData>({\n    refetchPage,\n    ...options\n  }: RefetchOptions & RefetchPageFilters<TPageData> = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: { refetchPage },\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.client.defaultQueryOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(this.client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  private computeRefetchInterval() {\n    return typeof this.options.refetchInterval === 'function'\n      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)\n      : this.options.refetchInterval ?? false\n  }\n\n  private updateRefetchInterval(nextInterval: number | false): void {\n    this.clearRefetchInterval()\n\n    this.currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.currentRefetchInterval) ||\n      this.currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.currentRefetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval(this.computeRefetchInterval())\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.currentQuery\n    const prevOptions = this.options\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.currentResultState\n    const prevResultOptions = this.currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.currentQueryInitialState\n    const prevQueryResult = queryChange\n      ? this.currentResult\n      : this.previousQueryResult\n\n    const { state } = query\n    let { dataUpdatedAt, error, errorUpdatedAt, fetchStatus, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!dataUpdatedAt) {\n          status = 'loading'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      options.keepPreviousData &&\n      !state.dataUpdatedAt &&\n      prevQueryResult?.isSuccess &&\n      status !== 'error'\n    ) {\n      data = prevQueryResult.data\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt\n      status = prevQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.selectFn\n      ) {\n        data = this.selectResult\n      } else {\n        try {\n          this.selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.selectResult = data\n          this.selectError = null\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError)\n          }\n          this.selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (options.placeholderData as PlaceholderDataFunction<TQueryData>)()\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.selectError = null\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError)\n            }\n            this.selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(prevResult?.data, placeholderData, options) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError as any\n      data = this.selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isLoading = status === 'loading'\n    const isError = status === 'error'\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.currentQuery, this.options)\n    this.currentResultState = this.currentQuery.state\n    this.currentResultOptions = this.options\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = { cache: true }\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n\n      if (\n        notifyOnChangeProps === 'all' ||\n        (!notifyOnChangeProps && !this.trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(notifyOnChangeProps ?? this.trackedProps)\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  private updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true\n    }\n\n    this.updateResult(notifyOptions)\n\n    if (this.hasListeners()) {\n      this.updateTimers()\n    }\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({ listener }) => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated',\n        })\n      }\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: typeof options['refetchOnMount'] &\n    typeof options['refetchOnWindowFocus'] &\n    typeof options['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n","import { difference, replaceAt } from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  QueryObserverOptions,\n  QueryObserverResult,\n  DefaultedQueryObserverOptions,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n  private observersMap: Record<string, QueryObserver>\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = []\n    this.result = []\n    this.observers = []\n    this.observersMap = {}\n\n    if (queries) {\n      this.setQueries(queries)\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: QueryObserverOptions[],\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.queries = queries\n\n    notifyManager.batch(() => {\n      const prevObservers = this.observers\n\n      const newObserverMatches = this.findMatchingObservers(this.queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newObserversMap = Object.fromEntries(\n        newObservers.map((observer) => [observer.options.queryHash, observer]),\n      )\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.observers = newObservers\n      this.observersMap = newObserversMap\n      this.result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n\n      this.notify()\n    })\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  getQueries() {\n    return this.observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.observers\n  }\n\n  getOptimisticResult(queries: QueryObserverOptions[]): QueryObserverResult[] {\n    return this.findMatchingObservers(queries).map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n  }\n\n  private findMatchingObservers(\n    queries: QueryObserverOptions[],\n  ): QueryObserverMatch[] {\n    const prevObservers = this.observers\n    const prevObserversMap = new Map(\n      prevObservers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const defaultedQueryOptions = queries.map((options) =>\n      this.client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: QueryObserverMatch[] =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObserversMap.get(defaultedOptions.queryHash)\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = new Set(\n      matchingObservers.map((match) => match.defaultedQueryOptions.queryHash),\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash),\n    )\n\n    const matchingObserversSet = new Set(\n      matchingObservers.map((match) => match.observer),\n    )\n    const unmatchedObservers = prevObservers.filter(\n      (prevObserver) => !matchingObserversSet.has(prevObserver),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.client.defaultQueryOptions(options)\n      const currentObserver = this.observersMap[defaultedOptions.queryHash!]\n      return currentObserver ?? new QueryObserver(this.client, defaultedOptions)\n    }\n\n    const newOrReusedObservers: QueryObserverMatch[] = unmatchedQueries.map(\n      (options, index) => {\n        if (options.keepPreviousData) {\n          // return previous data from one of the observers that no longer match\n          const previouslyUsedObserver = unmatchedObservers[index]\n          if (previouslyUsedObserver !== undefined) {\n            return {\n              defaultedQueryOptions: options,\n              observer: previouslyUsedObserver,\n            }\n          }\n        }\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      },\n    )\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result)\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(this.result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n","import type {\n  DefaultedInfiniteQueryObserverOptions,\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions, ObserverFetchOptions } from './queryObserver'\nimport { QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\nimport type { Query } from './query'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>,\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  InfiniteData<TData>,\n  InfiniteData<TQueryData>,\n  TQueryKey\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>,\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions: ObserverFetchOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    super.setOptions(\n      {\n        ...options,\n        behavior: infiniteQueryBehavior(),\n      },\n      notifyOptions,\n    )\n  }\n\n  getOptimisticResult(\n    options: DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    options.behavior = infiniteQueryBehavior()\n    return super.getOptimisticResult(options) as InfiniteQueryObserverResult<\n      TData,\n      TError\n    >\n  }\n\n  fetchNextPage({ pageParam, ...options }: FetchNextPageOptions = {}): Promise<\n    InfiniteQueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'forward', pageParam },\n      },\n    })\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  }: FetchPreviousPageOptions = {}): Promise<\n    InfiniteQueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'backward', pageParam },\n      },\n    })\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, InfiniteData<TQueryData>, TQueryKey>,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = query\n    const result = super.createResult(query, options)\n\n    const { isFetching, isRefetching } = result\n\n    const isFetchingNextPage =\n      isFetching && state.fetchMeta?.fetchMore?.direction === 'forward'\n\n    const isFetchingPreviousPage =\n      isFetching && state.fetchMeta?.fetchMore?.direction === 'backward'\n\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data?.pages),\n      hasPreviousPage: hasPreviousPage(options, state.data?.pages),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching:\n        isRefetching && !isFetchingNextPage && !isFetchingPreviousPage,\n    }\n  }\n}\n","import type { Action, Mutation } from './mutation'\nimport { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverBaseResult,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\nimport { shallowEqualObjects } from './utils'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options\n    this.options = this.client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this,\n      })\n    }\n    this.currentMutation?.setOptions(this.options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    const result: MutationObserverBaseResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    > = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n\n    this.currentResult = result as MutationObserverResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!,\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach(({ listener }) => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n","import type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from './types'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  dehydrateMutations?: boolean\n  dehydrateQueries?: boolean\n  shouldDehydrateMutation?: ShouldDehydrateMutationFunction\n  shouldDehydrateQuery?: ShouldDehydrateQueryFunction\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\nexport type ShouldDehydrateQueryFunction = (query: Query) => boolean\n\nexport type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nexport function defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nexport function defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {},\n): DehydratedState {\n  const mutations: DehydratedMutation[] = []\n  const queries: DehydratedQuery[] = []\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation =\n      options.shouldDehydrateMutation || defaultShouldDehydrateMutation\n\n    client\n      .getMutationCache()\n      .getAll()\n      .forEach((mutation) => {\n        if (shouldDehydrateMutation(mutation)) {\n          mutations.push(dehydrateMutation(mutation))\n        }\n      })\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery =\n      options.shouldDehydrateQuery || defaultShouldDehydrateQuery\n\n    client\n      .getQueryCache()\n      .getAll()\n      .forEach((query) => {\n        if (shouldDehydrateQuery(query)) {\n          queries.push(dehydrateQuery(query))\n        }\n      })\n  }\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions,\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach((dehydratedMutation) => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state,\n    )\n  })\n\n  queries.forEach((dehydratedQuery) => {\n    const query = queryCache.get(dehydratedQuery.queryHash)\n\n    // Reset fetch status to idle in the dehydrated state to avoid\n    // query being stuck in fetching state upon hydration\n    const dehydratedQueryState = {\n      ...dehydratedQuery.state,\n      fetchStatus: 'idle' as const,\n    }\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQueryState.dataUpdatedAt) {\n        query.setState(dehydratedQueryState)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey: dehydratedQuery.queryKey,\n        queryHash: dehydratedQuery.queryHash,\n      },\n      dehydratedQueryState,\n    )\n  })\n}\n","'use client'\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client\n      .getLogger()\n      .error(\n        `The contextSharing option has been deprecated and will be removed in the next major version`,\n      )\n  }\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","'use client'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  UseErrorBoundary,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  useErrorBoundary: UseErrorBoundary<\n    TQueryFnData,\n    TError,\n    TQueryData,\n    TQueryKey\n  >\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(useErrorBoundary, [result.error, query])\n  )\n}\n","import type { DefaultedQueryObserverOptions } from '@tanstack/query-core'\nimport type { QueryObserver } from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport type { QueryObserverResult } from '@tanstack/query-core'\nimport type { QueryKey } from '@tanstack/query-core'\n\nexport const ensureStaleTime = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer\n    .fetchOptimistic(defaultedOptions)\n    .then(({ data }) => {\n      defaultedOptions.onSuccess?.(data as TData)\n      defaultedOptions.onSettled?.(data, null)\n    })\n    .catch((error) => {\n      errorResetBoundary.clearReset()\n      defaultedOptions.onError?.(error)\n      defaultedOptions.onSettled?.(undefined, error)\n    })\n","'use client'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryFunction } from '@tanstack/query-core'\nimport { notifyManager, QueriesObserver } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  shouldSuspend,\n  fetchOptimistic,\n  willFetch,\n} from './suspense'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const optimisticResult = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result, isRestoring),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const options = defaultedQueries[index]\n        const queryObserver = observer.getObservers()[index]\n\n        if (options && queryObserver) {\n          if (shouldSuspend(options, result, isRestoring)) {\n            return fetchOptimistic(options, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(options, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return optimisticResult as QueriesResults<T>\n}\n","'use client'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryObserver } from '@tanstack/query-core'\nimport { notifyManager } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseBaseQueryOptions } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic } from './suspense'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange))\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      useErrorBoundary: defaultedOptions.useErrorBoundary,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","'use client'\nimport type { QueryFunction, QueryKey } from '@tanstack/query-core'\nimport { parseQueryArgs, QueryObserver } from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n","'use client'\nimport * as React from 'react'\n\nimport type { HydrateOptions } from '@tanstack/query-core'\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { ContextOptions } from './types'\n\nexport function useHydrate(\n  state: unknown,\n  options: HydrateOptions & ContextOptions = {},\n) {\n  const queryClient = useQueryClient({ context: options.context })\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n  children?: React.ReactNode\n}\n\nexport const Hydrate = ({ children, options, state }: HydrateProps) => {\n  useHydrate(state, options)\n  return children as React.ReactElement\n}\n","'use client'\nimport * as React from 'react'\nimport type { QueryKey, QueryFilters } from '@tanstack/query-core'\nimport { notifyManager, parseFilterArgs } from '@tanstack/query-core'\n\nimport { useSyncExternalStore } from './useSyncExternalStore'\nimport type { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsFetching(filters?: QueryFilters, options?: Options): number\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters,\n  options?: Options,\n): number\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseFilterArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n  const queryCache = queryClient.getQueryCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => queryClient.isFetching(filters),\n    () => queryClient.isFetching(filters),\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { MutationKey, MutationFilters } from '@tanstack/query-core'\nimport { notifyManager, parseMutationFilterArgs } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  options?: Options,\n): number\nexport function useIsMutating(\n  mutationKey?: MutationKey,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n  options?: Options,\n): number\nexport function useIsMutating(\n  arg1?: MutationKey | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'> | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseMutationFilterArgs(arg1, arg2, arg3)\n\n  const queryClient = useQueryClient({ context: options.context })\n  const mutationCache = queryClient.getMutationCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [mutationCache],\n    ),\n    () => queryClient.isMutating(filters),\n    () => queryClient.isMutating(filters),\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { MutationFunction, MutationKey } from '@tanstack/query-core'\nimport {\n  notifyManager,\n  parseMutationArgs,\n  MutationObserver,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","'use client'\nimport type {\n  QueryObserver,\n  QueryFunction,\n  QueryKey,\n} from '@tanstack/query-core'\nimport { InfiniteQueryObserver, parseQueryArgs } from '@tanstack/query-core'\nimport type { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg3?: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n"],"names":["e","require","k","Object","is","a","b","l","useState","m","useEffect","n","useLayoutEffect","p","useDebugValue","r","getSnapshot","value","d","f","u","window","document","createElement","inst","c","g","exports","useSyncExternalStore","module","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","error","done","Promise","then","_asyncToGenerator","fn","self","this","args","arguments","apply","err","undefined","_iterableToArray","iter","Symbol","iterator","Array","from","_objectWithoutProperties","source","excluded","i","target","sourceKeys","keys","length","indexOf","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","call","_regeneratorRuntime","Op","hasOwn","hasOwnProperty","defineProperty","obj","desc","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","enumerable","configurable","writable","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","create","context","Context","makeInvokeMethod","tryCatch","type","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","method","_invoke","AsyncIterator","PromiseImpl","invoke","record","result","__await","unwrapped","previousPromise","callInvokeWithMethodAndArg","state","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","methodName","TypeError","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","val","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","_toConsumableArray","arr","isArray","arrayLikeToArray","iterableToArray","unsupportedIterableToArray","Subscribable","_classCallCheck","listeners","Set","subscribe","bind","_createClass","listener","_this","identity","add","onSubscribe","delete","onUnsubscribe","size","isServer","noop","isValidTimeout","Infinity","difference","array1","array2","filter","x","includes","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","_objectSpread","queryKey","queryFn","parseMutationArgs","mutationKey","mutationFn","parseFilterArgs","parseMutationFilterArgs","matchQuery","filters","query","_filters$type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","matchMutation","mutation","fetching","hashQueryKey","status","queryKeyHashFn","JSON","stringify","_","isPlainObject","sort","reduce","partialDeepEqual","some","replaceEqualDeep","array","isPlainArray","aSize","bItems","bSize","copy","equalItems","shallowEqualObjects","o","hasObjectPrototype","prot","toString","isError","sleep","timeout","setTimeout","scheduleMicrotask","callback","replaceData","prevData","data","isDataEqual","structuralSharing","focusManager","_Subscribable","_inherits","FocusManager","_super","_createSuper","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","hasListeners","_this$cleanup2","_this2","focused","setFocused","_ref","visibilityState","onlineEvents","onlineManager","OnlineManager","onOnline","event","online","setOnline","navigator","onLine","defaultRetryDelay","failureCount","min","pow","canFetch","networkMode","isOnline","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","promise","outerResolve","outerReject","shouldPause","isFocused","onSuccess","onError","pause","continueResolve","canContinue","onPause","onContinue","run","promiseOrValue","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","_get","Reflect","get","property","receiver","base","getOwnPropertyDescriptor","defaultLogger","console","notifyManager","queue","transactions","notifyFn","batchNotifyFn","schedule","flush","originalQueue","batch","batchCalls","_len","_key","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","clearGcTimeout","cacheTime","gcTimeout","optionalRemove","newCacheTime","clearTimeout","Query","_Removable","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","getDefaultState","scheduleGc","meta","updateCacheTime","remove","newData","dispatch","manual","setStateOptions","_this$retryer","retryer","_getPrototypeOf","destroy","setState","observer","enabled","getObserversCount","getCurrentResult","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","notify","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","AbortController","getAbortController","queryFnContext","pageParam","addSignalProperty","signal","_context$fetchOptions2","fetchFn","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","onSettled","isFetchingOptimistic","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","setData","action","_this3","_action$meta","_action$dataUpdatedAt","reducer","onQueryUpdate","QueryCache","queries","queriesMap","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","queryInMap","_parseFilterArgs","_slicedToArray","_parseFilterArgs3","_this4","_this5","Mutation","mutationId","mutationCache","_this$retryer$continu","execute","_execute","_callee","executeMutation","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","_this$mutationCache$c7","_this$mutationCache$c8","_this$options$onError","_this$options4","_this$mutationCache$c9","_this$mutationCache$c10","_this$options$onSettl2","_this$options5","_context","_this$options$retry","variables","onMutate","t0","failureReason","isPaused","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","_this$resuming","resuming","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","concat","fetchPage","_context$signal","_context$signal2","aborted","queryFnResult","getNextPageParam","getPreviousPageParam","shouldFetchFirstPage","_loop","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryClient","queryCache","queryDefaults","mutationDefaults","mountCount","unsubscribeFocus","resumePausedMutations","unsubscribeOnline","_this$unsubscribeFocu","_this$unsubscribeOnli","findAll","_this$queryCache$find","parsedOptions","cachedData","getQueryData","fetchQuery","queryKeyOrFilters","getQueryCache","map","_ref2","updater","input","functionalUpdate","defaultedOptions","build","_ref3","setQueryData","_this$queryCache$find2","_parseFilterArgs5","_parseFilterArgs6","refetchFilters","refetchQueries","_parseFilterArgs7","_parseFilterArgs8","_parseFilterArgs8$","promises","all","_parseFilterArgs9","_parseFilterArgs10","_filters$refetchType","invalidate","refetchType","_this6","_parseFilterArgs11","_parseFilterArgs12","isDisabled","_options$cancelRefetc","fetch","throwOnError","isStaleByTime","fetchInfiniteQuery","firstMatchingDefaults","_defaulted","refetchOnReconnect","useErrorBoundary","suspense","clear","QueryObserver","trackedProps","selectError","bindMethods","currentQuery","addObserver","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","removeObserver","notifyOptions","prevOptions","prevQuery","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","createResult","currentResult","trackedResult","_excluded","_fetchOptions$cancelR","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","keepPreviousData","isSuccess","select","selectFn","selectResult","process","placeholderData","isFetching","isLoading","isInitialLoading","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","_this7","nextResult","defaultNotifyOptions","notifyOnChangeProps","includedProps","typedKey","has","shouldNotifyListeners","_this8","retryOnMount","shouldLoadOnMount","refetchOnMount","field","QueriesObserver","observersMap","setQueries","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","newObserversMap","fromEntries","newResult","hasIndexChange","index","getCurrentQuery","getOptimisticResult","prevObserversMap","Map","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","matchingObserversSet","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","replaceAt","InfiniteQueryObserver","_QueryObserver","fetchNextPage","fetchPreviousPage","_excluded2","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","_state$data","_state$data2","MutationObserver","mutate","_this$currentMutation","getMutationCache","currentMutation","_this$currentMutation2","mutateOptions","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","dehydrate","dehydrateMutations","shouldDehydrateMutation","getAll","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery","hydrate","dehydratedState","dehydratedMutation","_options$defaultOptio","dehydratedQuery","_options$defaultOptio2","dehydratedQueryState","useSyncExternalStore$1","defaultContext","React","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","QueryClientProvider","_ref2$contextSharing","mount","unmount","IsRestoringContext","useIsRestoring","IsRestoringProvider","Provider","createValue","clearReset","isReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","QueryErrorResetBoundary","children","shouldThrowError","_useErrorBoundary","params","errorResetBoundary","useClearResetErrorBoundary","getHasError","ensureStaleTime","willFetch","isRestoring","shouldSuspend","fetchOptimistic","useQueries","defaultedQueries","ensurePreventErrorBoundaryRetry","_React$useState","optimisticResult","onStoreChange","suspensePromises","queryObserver","getObservers","observerQueries","getQueries","_defaultedQueries$ind","_defaultedQueries$ind2","firstSingleResultWhichShouldThrow","useBaseQuery","Observer","unsubscribe","trackResult","useQuery","useHydrate","optionsRef","current","Hydrate","useIsFetching","_parseFilterArgs2","_parseFilterArgs2$","useIsMutating","_parseMutationFilterA","_parseMutationFilterA2","_parseMutationFilterA3","isMutating","useMutation","useInfiniteQuery"],"sourceRoot":""}